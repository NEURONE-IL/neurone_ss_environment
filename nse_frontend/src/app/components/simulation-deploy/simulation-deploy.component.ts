import { Component, OnInit, OnDestroy, ViewChild, ElementRef, Renderer2 } from '@angular/core';
import { Router } from '@angular/router';
import { timer } from 'rxjs';

import { MatTable } from '@angular/material/table';
import { MatTableDataSource } from '@angular/material/table';
import { MatSort, MatSortable } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
import { MatDialog, MatDialogRef } from '@angular/material/dialog';

import * as dayjs from 'dayjs';

import { Simulation } from '../../models/simulation';
import { SimulationService } from '../../services/simulation.service';
import { SimulationDeployService } from '../../services/simulationDeploy.service';
import { SimulationDeployActiveService } from '../../services/simulationDeployActive.service';
import { SimulationDeployDataService } from '../../services/simulationDeployData.service';
import { SimulationModalConfirmDeployLeaveComponent } from '../simulation-modal-confirmdeployleave/simulation-modal-confirmdeployleave.component';

import { CatchNotFoundErrorService } from '../../services/catchNotFoundError.service';

import { BehaviorModel } from '../../models/behaviorModel';
import { BehaviorModelService } from '../../services/behaviorModel.service';

import { CdTimerModule } from 'angular-cd-timer';

// Interface to handle the actions as presented to the user in the actions table of this component
interface Action {
  username: string,
  action: string,
  localTimestamp: string,
  numberTimestamp: number,
  type: string
}

// Interface to handle the bookmarks/unbookmarks data generated by the student simulator
interface Bookmark {
  _id: string,
  username: string,
  url: string,
  localTimestamp: number,
  action: string,
  docid: string,
  relevant: boolean,
  usermade: boolean
}

// Interface to handle the keystroke data generated by the student simulator
interface Keystroke {
  _id: string,
  username: string,
  url: string,
  localTimestamp: number,
  keyCode: number
}

// Interface to handle the query data generated by the student simulator
interface Query {
  _id: string,
  username: string,
  url: string,
  localTimestamp: number,
  query: string
}

// Interface to handle the visited links data generated by the student simulator
interface Visitedlink {
  _id: string,
  username: string,
  url: string,
  state: string,
  localTimestamp: number,
  relevant: boolean
}

@Component({
  selector: 'app-simulation-deploy',
  templateUrl: './simulation-deploy.component.html',
  styleUrls: ['./simulation-deploy.component.css']
})

// Simulation deploy view
export class SimulationDeployComponent implements OnInit {

  private _id: string = '';                 // ID of the simulation settings that will be used for the deploy
  private deployName: string = '';          // Name of the simulation deploy that will be generated based on the simulation settings
  public simulationName: string = '';
  public deployEnabled: boolean = true;
  public stopEnabled: boolean = false;
  public restartEnabled: boolean = false;
  public endTime: number = 0;
  public showMaxLengthReached: boolean = false;

  private actionsList: Action[] = [];

  private bookmarksList: Bookmark[] = [];
  private keystrokesList: Keystroke[] = [];
  private queriesList: Query[] = [];
  private visitedlinksList: Visitedlink[] = [];

  public columns = ['username', 'action', 'localTimestamp'];
  public dataSource: any;
  public filterInput: string = "";

  private bookmarksCursor: number = 0;
  private keystrokesCursor: number = 0;
  private queriesCursor: number = 0;
  private visitedlinksCursor: number = 0;

  private bookmarksNumberElemsToSkip: number = 0;
  private keystrokesNumberElemsToSkip: number = 0;
  private queriesNumberElemsToSkip: number = 0;
  private visitedlinksNumberElemsToSkip: number = 0;

  private updateFrequency: number = 5000;
  private updateActionsFinished: boolean = true;

  public statusString1 = $localize`:Status text in the Simulation Deploy component:Stopped`;
  public statusString2 = $localize`:Status text in the Simulation Deploy component:Deploying...`;
  public statusString3 = $localize`:Status text in the Simulation Deploy component:Deployed`;
  public statusString4 = $localize`:Status text in the Simulation Deploy component:Stopping...`;
  public statusString5 = $localize`:Status text in the Simulation Deploy component:Restarting...`;
  public status: string = this.statusString1;

  private emptyActionsTableString1 = $localize`:Text displayed when the actions table is empty in the Simulation Deploy component:Press the start deploy button to generate actions.`;
  private emptyActionsTableString2 = $localize`:Text displayed when the actions table is empty in the Simulation Deploy component:No actions received yet.`;
  private emptyActionsTableString3 = $localize`:Text displayed when the actions table is empty in the Simulation Deploy component:No actions found.`;
  public emptyActionsTableText: string = this.emptyActionsTableString1;

  private dayjsFormat = $localize`:Date format for the Dayjs library, to be used while displaying the timestamps of student actions generated by the simulator:YYYY/MM/DD HH:mm:ss.SSS`;

  @ViewChild(MatSort, {static: true}) private sort!: MatSort;
  @ViewChild(MatTable, {static: true}) private ActionsTableRef!: MatTable<any>;
  @ViewChild('basicTimer') private timerRef!: any;
  @ViewChild('actionText') actionTextRef!: ElementRef;
  @ViewChild(MatPaginator) paginator!: MatPaginator;

  // Constructor: Injects dependencies, and redirects the user to the home page in case no simulation ID has been provided
  constructor(private _simulationService: SimulationService,
              private _behaviorModelService: BehaviorModelService,
              private _simulationDeployService: SimulationDeployService,
              private _simulationDeployActiveService: SimulationDeployActiveService,
              private _simulationDeployDataService: SimulationDeployDataService,
              private router: Router,
              private _renderer2: Renderer2,
              private _matDialog: MatDialog,
              private _catchNotFoundErrorService: CatchNotFoundErrorService) {

      if (this.router.getCurrentNavigation()?.extras.state! !== undefined) {
        this._id = this.router.getCurrentNavigation()?.extras.state!['_id'];
      } else {
        this.router.navigate(['/', 'home']);
      }
  }

  // ngOnInit: Retrieves the data needed for the simulation deploy component, configures the simulation timer, and initializes the actions table and its sorting and paginator functionalities
  async ngOnInit() {
    try {
      let simulation = await this._simulationService.getSimulation(this._id).toPromise();
      this.simulationName = simulation.name;

      if (simulation.length == -1) {
        this.endTime = 0
      } else {
        this.endTime = simulation.length * 60;
      }

      this.dataSource = new MatTableDataSource<Action>(this.actionsList);
      this.dataSource.sort = this.sort;

      this.dataSource.sortData = (data: Action[], sort: MatSort) => {
        return data.sort((a: Action, b: Action): number => {
          if (this.sort.active === "username") {
            if (this.sort.direction === "asc") {
              return Number(parseInt(a.username.replace("Student ", "")) > parseInt(b.username.replace("Student ", "")));
            } else if (this.sort.direction === "desc") {
              return Number(parseInt(b.username.replace("Student ", "")) > parseInt(a.username.replace("Student ", "")));
            }
          }
          else if (this.sort.active === "action") {
            if (this.sort.direction === "asc") {
              return Number(a.action.toLowerCase() > b.action.toLowerCase());
            } else if (this.sort.direction === "desc") {
              return Number(b.action.toLowerCase() > a.action.toLowerCase());
            }
          }
          else if (this.sort.active === "localTimestamp") {
            if (this.sort.direction === "asc") {
              return dayjs(a.localTimestamp, this.dayjsFormat).toDate().getTime() - dayjs(b.localTimestamp, this.dayjsFormat).toDate().getTime();
            } else if (this.sort.direction === "desc") {
              return dayjs(b.localTimestamp, this.dayjsFormat).toDate().getTime() - dayjs(a.localTimestamp, this.dayjsFormat).toDate().getTime();
            }
          }
          return 0;
        });
      }

      this.dataSource.filterPredicate = (data: Action, filter: string) => data.username === filter;

      this.timerRef.stop();

      this.dataSource.paginator = this.paginator;
    } catch (error: any) {
      this._catchNotFoundErrorService.catchSimulationNotFoundError(error);
      return;
    }
  }

  // Navigates to the simulation settings component
  public goToSimulationSettings = async () => {
    if (this._simulationDeployActiveService.getDeployActiveStatus() == true) {
      const dialogRef = this._matDialog.open(SimulationModalConfirmDeployLeaveComponent, { width: '45%', disableClose: true } );

      const sub = dialogRef.componentInstance.onSubmit.subscribe(async() => {
        dialogRef.close();

        try {
          let simulation = await this._simulationService.getSimulation(this._id).toPromise();
        } catch (error: any) {
          this._catchNotFoundErrorService.catchSimulationNotFoundError(error);
          return;
        }

        this.router.navigate(['/', 'simulation-settings'], { state:
          { _id: this._id
        }});
      }, (error: any) => {
        console.log(error);
      })

      dialogRef.afterClosed().subscribe(() => {
        sub.unsubscribe();
      });
    } else {
      try {
        let simulation = await this._simulationService.getSimulation(this._id).toPromise();
      } catch (error: any) {
        this._catchNotFoundErrorService.catchSimulationNotFoundError(error);
        return;
      }

      this.router.navigate(['/', 'simulation-settings'], { state:
        { _id: this._id
      }});
    }
  }

  // Applies a filter to the actions table
  public applyFilter = (event: Event) => {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    this.paginator.firstPage();
  }

  // Clears the actions table filter
  public removeFilter = () => {
    this.filterInput = "";
    this.dataSource.filter = "";
    this.paginator.firstPage();
  }

  // Deploys a simulation
  public deploy = async () => {
    try {
      this.deployEnabled = false;
      this.status = this.statusString2;

      this._simulationDeployActiveService.setDeployActive();
      this.showMaxLengthReached = false;
      this.emptyActionsTableText = this.emptyActionsTableString2;
      this.timerRef.reset();
      this.timerRef.start();

      this.actionsList.length = 0;
      this.bookmarksList.length = 0;
      this.keystrokesList.length = 0;
      this.queriesList.length = 0;
      this.visitedlinksList.length = 0;
      this.ActionsTableRef.renderRows();
      this.dataSource._updateChangeSubscription();

      this.bookmarksCursor = 0;
      this.keystrokesCursor = 0;
      this.queriesCursor = 0;
      this.visitedlinksCursor = 0;

      this.bookmarksNumberElemsToSkip = 0;
      this.keystrokesNumberElemsToSkip = 0;
      this.queriesNumberElemsToSkip = 0;
      this.visitedlinksNumberElemsToSkip = 0;

      let deployData = await this._simulationDeployService.startSimulation(this._id).toPromise();
      this.deployName = deployData.deployName;
      this.status = this.statusString3;
      this.stopEnabled = true;
      this.restartEnabled = true;

      this.updateActions();

      let updateLastDeployDate = await this._simulationService.updateSimulationLastDeployDate(this._id).toPromise();
    } catch (error: any) {
      this._catchNotFoundErrorService.catchSimulationNotFoundError(error);
      return;
    }
  }

  // Periodically retrieves more generated data of a deployed simulation, in order to display it on the actions table
  private updateActions = async () => {
    try {
      this.updateActionsFinished = false;
      while ((this.status === this.statusString3) && (this._simulationDeployActiveService.getDeployActiveStatus() == true)) {
        if ((this.status === this.statusString3) && (this._simulationDeployActiveService.getDeployActiveStatus() == true)) {
          await new Promise(f => setTimeout(f, this.updateFrequency));
        }

        let latestBookmarks = await this._simulationDeployDataService.getLatestBookmarks(this.deployName, this.bookmarksCursor).toPromise();
        let latestKeystrokes = await this._simulationDeployDataService.getLatestKeystrokes(this.deployName, this.keystrokesCursor).toPromise();
        let latestQueries = await this._simulationDeployDataService.getLatestQueries(this.deployName, this.queriesCursor).toPromise();
        let latestVisitedlinks = await this._simulationDeployDataService.getLatestVisitedlinks(this.deployName, this.visitedlinksCursor).toPromise();

        latestBookmarks.splice(0, this.bookmarksNumberElemsToSkip);
        latestKeystrokes.splice(0, this.keystrokesNumberElemsToSkip);
        latestQueries.splice(0, this.queriesNumberElemsToSkip);
        latestVisitedlinks.splice(0, this.visitedlinksNumberElemsToSkip);

        if (latestBookmarks.length > 0) {
          this.bookmarksCursor = latestBookmarks[latestBookmarks.length - 1].localTimestamp;
        }

        if (latestKeystrokes.length > 0) {
          this.keystrokesCursor = latestKeystrokes[latestKeystrokes.length - 1].localTimestamp;
        }

        if (latestQueries.length > 0) {
          this.queriesCursor = latestQueries[latestQueries.length - 1].localTimestamp;
        }

        if (latestVisitedlinks.length > 0) {
          this.visitedlinksCursor = latestVisitedlinks[latestVisitedlinks.length - 1].localTimestamp;
        }

        if (latestBookmarks.length > 0) {
          this.bookmarksNumberElemsToSkip = 0;
          let i = latestBookmarks.length - 1;
          while (i >= 0) {
            if (latestBookmarks[i].localTimestamp == this.bookmarksCursor) {
              this.bookmarksNumberElemsToSkip = this.bookmarksNumberElemsToSkip + 1;
              i = i - 1
            } else {
              break;
            }
          }
        }

        if (latestKeystrokes.length > 0) {
          this.keystrokesNumberElemsToSkip = 0;
          let i = latestKeystrokes.length - 1;
          while (i >= 0) {
            if (latestKeystrokes[i].localTimestamp == this.keystrokesCursor) {
              this.keystrokesNumberElemsToSkip = this.keystrokesNumberElemsToSkip + 1;
              i = i - 1
            } else {
              break;
            }
          }
        }

        if (latestQueries.length > 0) {
          this.queriesNumberElemsToSkip = 0;
          let i = latestQueries.length - 1;
          while (i >= 0) {
            if (latestQueries[i].localTimestamp == this.queriesCursor) {
              this.queriesNumberElemsToSkip = this.queriesNumberElemsToSkip + 1;
              i = i - 1
            } else {
              break;
            }
          }
        }

        if (latestVisitedlinks.length > 0) {
          this.visitedlinksNumberElemsToSkip = 0;
          let i = latestVisitedlinks.length - 1;
          while (i >= 0) {
            if (latestVisitedlinks[i].localTimestamp == this.visitedlinksCursor) {
              this.visitedlinksNumberElemsToSkip = this.visitedlinksNumberElemsToSkip + 1;
              i = i - 1
            } else {
              break;
            }
          }
        }

        let tempActionsList: Action[] = [];

        for (let i = 0; i < latestBookmarks.length; i++) {
          let timestamp = dayjs(latestBookmarks[i].localTimestamp).format(this.dayjsFormat);
          if (latestBookmarks[i].action === "Bookmark") {
            let actionString1 = $localize`:Text of the actions table in the Simulation Deploy component:Student bookmarked document "${latestBookmarks[i].url}"`;
            tempActionsList.push({'username': latestBookmarks[i].username.substr(11), 'action': actionString1, 'localTimestamp': timestamp, 'numberTimestamp': latestBookmarks[i].localTimestamp, 'type': 'B'});
          } else {
            let actionString2 = $localize`:Text of the actions table in the Simulation Deploy component:Student unbookmarked document "${latestBookmarks[i].url}"`;
            tempActionsList.push({'username': latestBookmarks[i].username.substr(11), 'action': actionString2, 'localTimestamp': timestamp, 'numberTimestamp': latestBookmarks[i].localTimestamp, 'type': 'U'});
          }
        }

        for (let i = 0; i < latestKeystrokes.length; i++) {
          let timestamp = dayjs(latestKeystrokes[i].localTimestamp).format(this.dayjsFormat);
          let actionString3 = $localize`:Text of the actions table in the Simulation Deploy component:Student pressed key with keycode ${latestKeystrokes[i].keyCode.toString()}`;
          tempActionsList.push({'username': latestKeystrokes[i].username.substr(11), 'action': actionString3, 'localTimestamp': timestamp, 'numberTimestamp': latestKeystrokes[i].localTimestamp, 'type': 'K'});
        }

        for (let i = 0; i < latestQueries.length; i++) {
          let timestamp = dayjs(latestQueries[i].localTimestamp).format(this.dayjsFormat);
          let actionString4 = $localize`:Text of the actions table in the Simulation Deploy component:Student queried "${latestQueries[i].query}"`;
          tempActionsList.push({'username': latestQueries[i].username.substr(11), 'action': actionString4, 'localTimestamp': timestamp, 'numberTimestamp': latestQueries[i].localTimestamp, 'type': 'Q'});
        }

        for (let i = 0; i < latestVisitedlinks.length; i++) {
          let timestamp = dayjs(latestVisitedlinks[i].localTimestamp).format(this.dayjsFormat);

          if (latestVisitedlinks[i].state === "PageEnter") {
            let actionString5 = $localize`:Text of the actions table in the Simulation Deploy component:Student entered page "${latestVisitedlinks[i].url}"`;
            tempActionsList.push({'username': latestVisitedlinks[i].username.substr(11), 'action': actionString5, 'localTimestamp': timestamp, 'numberTimestamp': latestVisitedlinks[i].localTimestamp, 'type': 'V'});
          } else {
            let actionString6 = $localize`:Text of the actions table in the Simulation Deploy component:Student exited page "${latestVisitedlinks[i].url}"`;
            tempActionsList.push({'username': latestVisitedlinks[i].username.substr(11), 'action': actionString6, 'localTimestamp': timestamp, 'numberTimestamp': latestVisitedlinks[i].localTimestamp, 'type': 'V'});
          }
        }

        tempActionsList.sort((a, b) => a.numberTimestamp - b.numberTimestamp);

        for (let i = 0; i < tempActionsList.length; i++) {
          this.actionsList.push(tempActionsList[i]);
        }

        this.ActionsTableRef.renderRows();
        this.dataSource._updateChangeSubscription();
        this.emptyActionsTableText = this.emptyActionsTableString3;
      }
      this.updateActionsFinished = true;
    } catch (error) {
        console.log("The user left the simulation deploy view without stopping the simulation -- The backend will stop it by itself after a few seconds");
    }

  }

  // Stops a simulation
  public stop = async () => {
    this.showMaxLengthReached = false;
    this.stopEnabled = false;
    this.restartEnabled = false;
    this.status = this.statusString4;
    let status = await this._simulationDeployService.stopSimulation(this.deployName).toPromise();
    await new Promise(f => setTimeout(f, 3000));
    while (this.updateActionsFinished == false) {
      await new Promise(f => setTimeout(f, 500));
    }
    this.status = this.statusString1;
    this.deployEnabled = true;
    this.timerRef.stop();
    this._simulationDeployActiveService.setDeployInactive();
  }

  // Restarts a simulation (stops it and deploys it again)
  public restart = async () => {
    this.actionsList.length = 0;
    this.bookmarksList.length = 0;
    this.keystrokesList.length = 0;
    this.queriesList.length = 0;
    this.visitedlinksList.length = 0;
    this.ActionsTableRef.renderRows();
    this.dataSource._updateChangeSubscription();
    this.emptyActionsTableText = this.emptyActionsTableString2;

    this.showMaxLengthReached = false;
    this.restartEnabled = false;
    this.stopEnabled = false;
    this.status = this.statusString5;
    let status = await this._simulationDeployService.stopSimulation(this.deployName).toPromise();

    this.timerRef.stop();
    await new Promise(f => setTimeout(f, 1000));
    this.deploy();
  }

  // Causes the simulation timer to stop when the maximum length is reached
  public triggerStop() {
    if (this.endTime > 0) {
      this.stop();
      this.showMaxLengthReached = true;
    }
  }

}